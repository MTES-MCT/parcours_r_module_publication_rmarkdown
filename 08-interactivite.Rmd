---
editor_options: 
  markdown: 
    wrap: sentence
---

# Du Rmarkdown interactif

Quand notre produit de sortie est un pdf, on va vouloir g√©n√©rer des graphiques et cartes qui ont le comportement d'une image simple.
C'est ce que nous avons fait depuis le d√©but de ce cours.
Mais de plus en plus de nos projets sont destin√©s √† une publication web et un certain niveau d'interactivit√© est souhait√©.
La consid√©ration principale √† prendre en compte est l'environnement de d√©ploiement.
Si mon document est heberg√© sur un serveur R, j'ai la possibilit√© de lui faire ex√©cuter du code R "en direct" en fonction des actions de l'utilisateur.
Dans le cas contraire, il faudra utiliser de l'interactivit√© en javascript.
Ce langage est interpr√©t√© et ex√©cut√© directement par le navigateur du client (celui qui consulte la page).
Mais pas d'inqui√©tude, vous pouvez continuer √† coder uniquement en R, le javascript est cach√© derri√®re.

## Interactivit√© simple, les visuels s'animent

Lorsqu'on choisit le HTML comme format de sortie, on peu utiliser toutes les possibilit√©s d'animation des cartes et graphes vus dans [le module 5 - "Valoriser ses donn√©es avec R".](https://mtes-mct.github.io/parcours_r_module_datavisualisation/cr%C3%A9er-des-graphiques-et-cartes-pour-le-web.html)

Vous pouvez int√©grer des cartes leaflet, des cartes et graphiques ggiraph, des graphiques plotly et bien d'autres qui offrent des possibilit√©s d'animations au survol, d'infobulles, de zoom etc.
Ces widgets en n√©cessitent pas de d√©ploiement sur un serveur R pour fonctionner.
Ils sont ex√©cut√©s par le navigateur client.

On parle ici d'interactivit√© simple car il s'agit uniquement d'effets visuels dans le comportement des widgets mais il n'y a aucune modification des donn√©es d√©pendante de l'utilisateur.

## Interactivit√© avanc√©e, les inputs utilisateur

Dans certains cas, on souhaite que l'utilisateur puisse directement influencer les visuels, en filtrant une sous-partie du jeu de donn√©es par exemple.
Il existe une solution qui permet cela tout en restant dans le cadre d'une ex√©cution par le navigateur client : [le package Crosstalk](https://rstudio.github.io/crosstalk/index.html).

Le fonctionnement de base est tr√®s simple, on transforme notre objet (la dataframe qui contient les donn√©es affich√©es) en un objet partag√© (shared object en anglais) :

```{r}

library(crosstalk)

dataframe_partagee -> SharedData$new(dataframe)

```

Regardez comme cela est not√© dans l'environnement de travail.

On peut sp√©cifier un argument qui indique le nom d'une colonne de valeurs toutes diff√©rentes permettant d'identifier les lignes de mani√®re unique.
On peut voir √ßa comme une cl√© primaire en gestion de base de donn√©es.
Par d√©faut Crosstalk utilise le num√©ro de ligne.

```{r}

dataframe_partagee -> SharedData$new(dataframe, ~identifiant)

```

√Ä partir de l√†, on peut utiliser cet objet partag√© √† la fois dans un widget de filtre, dans un tableau et dans une carte dynamique pour que l'utilisateur puisse filtrer ses objets √† afficher.

```{r}
library(crosstalk)
library(leaflet)
library(DT)

dataframe_partagee -> SharedData$new(dataframe, ~identifiant)

filter_select(id = "mon_filtre", label = "Choisissez un identifiant", sharedData = dataframe_partagee, group = ~identifiant)

datatable(dataframe_partagee, ...)

leaflet(dataframe_partagee) %>% 
  addPolygons(...)

```

## Exercice X

A FAIRE - repartir de l'exemple de book LS par r√©gion et remplacer par une page seule avec filtre par r√©gion avec Crosstalk.

## Interactivit√© compl√®te, l'application Shiny embarqu√©e

√Ä condition de disposer d'un serveur R pour d√©ployer son document, il est possible d'int√©grer des objets interactifs Shiny (inputs et outputs) voire une application Shiny compl√®te dans un Rmarkdown.

Dans votre yaml, il faut inclure la ligne `runtime: shiny`, pour reprendre l'exemple du chapitre 6, cela donne :

``` md
title: "mon_premier_document"
author: "Moi" date: "31/10/2022"
runtime: shiny
output: html_document
params:
  annee: 2022
  region: Bretagne
  date: !r
  lubricate::today()
```

Vous pouvez voir que Rstudio vous propose d√©sormais "Run document" au lieu de "Knit".
Il comprend qu'il doit d√©sormais utiliser un moteur shiny pour permettre la visualisation du document.

√Ä partir de l√†, vous pouvez inclure directement des inputs et outputs Shiny dans votre document mais il y a un twist : contrairement √† une application Shiny avec une logique UI / serveur o√π vous devez pr√©voir des placeholders dans l'UI pour vos sorties de serveur, dans la version Rmarkdown vous pouvez directement appeler les fonctions de la famille `renderXXX()`.

Application Shiny classique :

```{r}

library(shiny)

ui <- bootstrapPage(
  
  selectInput("input_utilisateur", ...),
  
  plotOutput("mon_graph", ...)

)

server <- function(input, output) {
  
  output$mon_graph <- renderPlot({
    ggplot(...)
  })
  
}

shinyApp(ui = ui, server = server)


```

La m√™me chose en Rmarkdown :

``` md
---
runtime: shiny
output: html_document
---
```

```{r echo = FALSE}

selectInput("input_utilisateur")

```

```{r echo = FALSE}
renderPlot({
  
  ggplot()
  
})
```

La syntaxe s'en trouve simplifi√©e, c'est la structure du document Rmarkdown qui permet de g√©rer le placement des diff√©rents √©l√©ments dans l'interface.

Une autre option consiste √† directement int√©grer le code l'application Shiny tel quel dans le document Rmarkdown :

``` md
---
runtime: shiny
output: html_document
---
```

```{r echo = FALSE}

library(shiny)

ui <- bootstrapPage(
  
  selectInput("input_utilisateur", ...),
  
  plotOutput("mon_graph", ...)

)

server <- function(input, output) {
  
  output$mon_graph <- renderPlot({
    ggplot(...)
  })
  
}

shinyApp(ui = ui, server = server, options = list(height = 500))

```

L'argument "height" en option permet d'indiquer la place (ici par d√©faut en pixel) que doit occuper l'application dans le document.

La r√©ciproque est vraie, il est possible d'inclure des documents markdown dans une application Shiny (souvent utilis√© pour la page d'accueil) en utilisant la fonction `includeMarkdown("mon_markdown.md")` √† l'int√©rieur de l'UI.
Il est donc possible d'inclure dans une app Shiny un markdown qui lui m√™me contient une application Shiny...ü§Ø
